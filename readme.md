# 小红书图卡生成工具

本项目是一个使用 Next.js 构建的在线工具，旨在帮助用户轻松创建和生成适合社交媒体（如小红书）风格的精美图卡。用户可以输入文本内容，选择不同主题风格，程序会自动解析内容并生成可预览的卡片图片。

## 项目目标

- 提供一个用户友好的界面，供用户输入和编辑多段卡片内容。
- 支持通过特定标记（如`---`, `页眉：`, `#`等）自动解析文本，提取页眉、页脚、主标题、副标题和正文。
- 提供多种预设的图卡风格（例如：赛博朋克、苹果备忘录、少女手账本等）供用户选择。
- 根据用户输入的内容和选择的风格，动态生成卡片预览。
- ✅ 支持用户下载生成的卡片为PNG图片文件。

## 技术栈

- **前端框架**: Next.js
- **样式**: Tailwind CSS + 自定义 CSS (用于卡片风格)
- **图片生成**: dom-to-image-more (支持将生成的卡片预览转换为可下载的图片)

## 主要功能与使用流程

1.  **选择风格**:
    *   在页面上方的下拉菜单中选择你想要的图卡风格（如：赛博朋克、苹果备忘录、少女手账本）。
2.  **粘贴内容**:
    *   在左侧的"粘贴完整内容"文本框中，输入或粘贴你的图卡文字。
    *   请参照文本框下方的"内容拆分与字段识别规则"以及新增的"内联文本样式规则"来组织你的文本，以便程序能准确识别和展示卡片的各个部分。
3.  **拆分与审核**:
    *   点击"拆分内容"按钮。
    *   程序会根据分隔符 `---` 将文本切分成多张卡片，并尝试根据规则自动提取每张卡片的页眉、主标题、副标题、正文和页脚。
    *   这些提取出来的内容会显示在右侧的"审核并编辑各卡片内容"区域，每个字段都有独立的输入框，方便你检查和修改。
4.  **生成预览**:
    *   确认右侧各字段内容无误后，点击"生成卡片预览"按钮。
    *   下方会显示根据你选择的风格和编辑好的内容生成的卡片预览图。预览图会忠实反映所选风格的视觉效果，包括特殊的内联文本样式。
5.  **清除卡片** (预览阶段):
    *   在卡片预览区，每张卡片的下方都有一个"清除这张卡片"按钮，可以从当前预览中移除不满意的卡片。
6.  **下载卡片** (预览阶段):
    *   在每张生成的卡片预览下方，你会看到一个"下载这张卡片"的按钮。点击它可以单独下载当前这张卡片为 PNG 图片文件。
    *   在所有卡片预览的底部，有一个"下载全部 X 张卡片"的按钮。点击它可以按顺序下载当前预览的所有卡片。
    *   图片会以 `卡片_序号.png` (例如 `卡片_001.png`) 的格式命名，并直接保存到你电脑的默认下载文件夹中。

## 内容拆分与字段识别规则 (简要)

-   **卡片分隔**: `---` (独占一行)
-   **页眉**: `页眉：文本内容` (独占一行)
-   **页脚**: `页脚：文本内容` (独占一行)
-   **主标题**: `# 文本内容` 或 `# 文本内容` (独占一行)
-   **副标题**: `### 文本内容` 或 `### 文本内容` (独占一行)
-   **正文**: 未被以上规则匹配的行。

*(详细规则请参照页面左侧输入框下方的说明)*

## 内联文本样式规则 (在正文行内生效)

-   **注释样式**: 以 `//` 开头的行，会以特定样式显示（例如，赛博朋克风格中为辅助灰色文字）。
-   **引用块样式**: 以 `>` 开头的行，会以特定引用块样式显示（例如，赛博朋克风格中带有霓虹粉色左边框和橙色文字）。
-   **行内代码/强调样式**: 使用反引号 `` ` `` 包裹的内容 (例如 `` `这里是代码或强调内容` ``)，会以特定背景和字体颜色突出显示。

这些内联样式会根据所选的整体卡片风格（赛博朋克、苹果备忘录、少女手账本）有不同的视觉表现。

## 如何运行 (本地开发)

1.  **安装依赖**：
    ```bash
    npm install
    # 或者
    yarn install
    ```
2.  **启动开发服务器**：
    ```bash
    npm run dev
    # 或者
    yarn dev
    ```
3.  在浏览器中打开 `http://localhost:3000` 查看。

## 目录结构 (主要)

- `pages/`: Next.js 页面
  - `index.js`: 应用主页面，包含主要逻辑和用户界面。
  - `_document.js`: 自定义文档，用于引入全局脚本如 `dom-to-image-more`。
  - `_app.js`: 自定义应用，引入全局样式。
- `components/`:
  - `ImageGenerator.js`: 负责渲染卡片预览的核心组件，并包含图片下载逻辑。
  - `CardInputForm.js`: 卡片输入表单组件(目前未使用)。
- `styles/`:
  - `cyberpunk.css`: 存放卡片风格的自定义CSS。
  - `imported-fonts.css`: 存放导入的字体。
  - `globals.css`: 全局样式，包含Tailwind CSS指令。
- `readme.md`: 本项目说明文件。

## 技术实现细节与经验总结

### 图片下载功能实现

本项目的核心功能之一是将用户在浏览器中看到的卡片预览准确无误地转换成可下载的图片文件。

**1. 实现概述:**

*   **核心库**: 我们选择了 `dom-to-image-more` 这个第三方JavaScript库。它能够将HTML DOM节点及其应用的CSS样式转换成多种图片格式的数据，我们主要使用的是PNG格式的Data URL。
*   **触发机制**:
    1.  当用户点击"下载这张卡片"或"下载全部卡片"按钮时，会调用相应的处理函数。
    2.  该函数首先定位到需要被截图的卡片DOM元素 (通过其 `id`)。
    3.  为了确保截图的完整性和视觉效果（特别是包含卡片周围的辉光效果并在最终图片中居中），我们采取了以下动态DOM操作步骤：
        *   **创建包裹层 (`captureWrapper`)**: 动态创建一个 `div` 元素。
        *   **设置包裹层样式**: 给这个包裹层设置固定的尺寸（例如 `510px x 660px`，略大于卡片实际内容尺寸），并使用Flexbox使其内部元素水平和垂直居中。同时，将当前卡片的主题样式类（如 `.card-style-cyberpunk`）也应用到这个包裹层上，以保持CSS样式的上下文。为了避免影响用户界面，该包裹层被绝对定位到屏幕外。
        *   **移动卡片**: 将目标卡片DOM元素移动到这个包裹层内部。
        *   **添加至DOM**: 将包裹层临时添加到 `document.body`。
    4.  调用 `domtoimage.toPng(captureWrapper, options)` 方法，传入配置参数（如 `quality`, `bgcolor`, `width`, `height`），得到图片的Base64编码的Data URL。
    5.  创建一个临时的 `<a>` (链接) 元素。
    6.  设置该链接的 `href` 属性为获取到的Data URL。
    7.  设置其 `download` 属性为期望的文件名 (例如 `卡片_001.png`)。
    8.  通过JavaScript模拟点击这个链接 (`link.click()`)，触发浏览器的文件下载行为。
    9.  **清理**: 下载触发后，从 `document.body` 中移除临时的链接元素和包裹层，并将卡片元素恢复到其在DOM中的原始位置，以保证页面状态的正确性。

**2. 遇到的主要问题与解决方案 ("避坑指南"):**

在实现图片下载功能的过程中，我们遇到了一系列挑战。以下是主要的"坑点"及其对应的解决方案，希望能为后续开发或类似功能提供参考：

*   **问题1: 第三方库CDN链接失效**
    *   **现象**: `dom-to-image-more` 库无法加载，浏览器控制台报404错误。
    *   **原因**: 初始使用的CDN链接版本已不可用。
    *   **解决**: 通过网络搜索确认 `dom-to-image-more` 可用的cdnjs CDN链接，并更新到较新的稳定版本 (如 `3.5.0`)。在 `pages/_document.js` 中更新 `<script>` 标签的 `src`。
    *   **建议**: 定期检查外部CDN依赖的有效性。对于核心功能依赖的库，考虑使用npm/yarn安装到项目本地，或选择有长期支持的CDN。

*   **问题2: 库加载时机与异步调用**
    *   **现象**: 即使CDN链接正确，有时调用 `domtoimage.toPng()` 依然报错，提示 `domtoimage`未定义；或者下载按钮在库完全可用前就被激活。
    *   **原因**: `dom-to-image-more` 通过CDN加载是异步的，脚本执行和全局变量 `domtoimage` 的挂载需要时间。
    *   **解决**:
        1.  在 `ImageGenerator.js` 组件中，使用 `useEffect` 钩子在组件挂载时启动一个定时器 (`setInterval`)。
        2.  该定时器轮询检查 `typeof domtoimage !== 'undefined'`。
        3.  一旦检测到库已加载，清除定时器，并使用 `useState` 设置一个状态变量 (如 `isDomToImageReady`) 为 `true`。
        4.  下载按钮的 `disabled` 状态和显示文本（如"加载中..." vs "下载"）与此状态变量绑定。
        5.  在实际调用下载函数前，再次检查此状态。
    *   **建议**: 务必处理好第三方异步库的加载状态，避免在库未就绪时调用其API。提供清晰的用户反馈（如加载指示）。

*   **问题3: Web字体在截图中显示为方框/乱码**
    *   **现象**: 下载的PNG图片中，使用了Google Fonts等Web字体的文本部分显示为方框或系统默认字体。
    *   **原因**: `dom-to-image-more` 在将DOM转为图片时，可能无法正确访问或嵌入通过外部 `<link>` 标签引用的远程字体文件，尤其是当这些字体文件受到跨域策略限制时。
    *   **解决**:
        1.  访问Google Fonts提供的CSS链接 (如 `https://fonts.googleapis.com/css2?family=...`)。
        2.  将其中的所有 `@font-face` 规则复制出来。
        3.  创建一个新的本地CSS文件 (例如 `public/styles/imported-fonts.css`)，并将复制的 `@font-face` 规则粘贴进去。
        4.  在 `pages/_app.js` 中直接导入这个本地CSS文件 (`import '../public/styles/imported-fonts.css';`)。
        5.  移除 `pages/_document.js` 中原有的Google Fonts `<link>` 标签。
    *   **建议**: 对于截图这类需要精确复制视觉外观的场景，将外部字体资源本地化或直接在CSS中定义 `@font-face` 规则（确保 `src url()` 指向可访问的字体文件，或使用Data URI嵌入字体）通常是更可靠的方案。

*   **问题4: Tailwind CSS部分样式在截图中丢失或不一致**
    *   **现象**: 下载的图片与浏览器预览相比，缺少一些Tailwind CSS应用的样式，或者出现非预期的边框/背景。
    *   **原因**: 项目初期可能混合使用了Tailwind CDN链接和不完整的本地配置。截图工具可能无法完美处理通过CDN `<link>` 标签引入的、依赖JavaScript动态生成或复杂处理的CSS框架。
    *   **解决**:
        1.  移除HTML中对Tailwind CDN的 `<link>` 引用。
        2.  确保项目中已安装 `tailwindcss`, `postcss`, `autoprefixer` 和 `@tailwindcss/postcss` 作为开发依赖。
        3.  正确配置项目根目录下的 `tailwind.config.js` (指定 `content` 扫描路径) 和 `postcss.config.js` (注册 `tailwindcss` 和 `autoprefixer` 插件，注意使用 `@tailwindcss/postcss` 作为PostCSS插件名)。
        4.  在全局CSS文件 (如 `styles/globals.css`) 中引入Tailwind的指令：`@tailwind base; @tailwind components; @tailwind utilities;`。
        5.  在 `pages/_app.js` 中导入这个全局CSS文件。
    *   **建议**: 对于使用Tailwind CSS这类工具链的项目，强烈建议遵循其官方推荐的安装和配置方式（通常是基于PostCSS），而不是仅依赖CDN版本，以确保开发、构建和截图时样式的一致性和完整性。

*   **问题5: 图片内容截断 (辉光效果、页脚等溢出部分丢失)**
    *   **现象**: 卡片底部的页脚文字或边缘的辉光效果 (`box-shadow`) 在下载的图片中被部分或完全截断。
    *   **原因**: `dom-to-image-more` 默认可能只捕获DOM元素的标准盒模型尺寸 (`offsetWidth`/`offsetHeight`)，而这些尺寸不包括超出元素边框的视觉效果（如 `box-shadow`）。
    *   **解决**: 在调用 `domtoimage.toPng(element, options)` 时，向 `options` 对象中明确传递 `width` 和 `height` 参数。这两个值应略大于目标元素本身的 `offsetWidth` 和 `offsetHeight`，以为溢出的视觉效果提供足够的"安全区"（例如，如果卡片是 `494x644`，可以尝试捕获 `510x660`）。
    *   **建议**: 当需要捕获包含 `box-shadow`, `outline`, 或其他会视觉上扩展元素边界的CSS效果时，需要预估这些效果所占据的额外空间，并相应调整截图的区域尺寸。

*   **问题6: 捕获区域大于内容时，内容未居中**
    *   **现象**: 为了包含辉光效果，截图区域被设置为大于卡片本身，但卡片内容在生成的图片中左上角对齐，导致底部和右侧出现不美观的空白边距。
    *   **原因**: `dom-to-image-more` 将目标元素绘制到指定尺寸的画布上时，默认采用左上角对齐。
    *   **解决**:
        1.  在截图前，动态创建一个临时的包裹 `div` 元素 (`captureWrapper`)。
        2.  设置此 `captureWrapper` 的 `width` 和 `height` 为最终期望的图片尺寸 (如 `510px`, `660px`)。
        3.  使用CSS Flexbox (`display: flex; justify-content: center; align-items: center;`) 使 `captureWrapper` 内部的内容（即卡片）水平和垂直居中。
        4.  将 `captureWrapper` 绝对定位到屏幕外 (`position: absolute; left: -9999px;`)，避免影响用户视图。
        5.  将被截图的卡片元素从其原始DOM位置**移动**到 `captureWrapper` 内部。
        6.  将 `captureWrapper` 添加到 `document.body`。
        7.  调用 `domtoimage.toPng(captureWrapper, options)`，此时截图目标是 `captureWrapper`。
        8.  截图操作完成后（在 `finally` 块中确保执行），将被移动的卡片元素恢复到其原始DOM位置，并从 `document.body` 中移除 `captureWrapper`。
    *   **建议**: 对于需要精确控制布局的截图，可以考虑在截图前对DOM进行临时的、可恢复的结构调整，利用CSS实现期望的布局（如居中），然后再进行截图。务必确保DOM操作的原子性和清理的彻底性。

*   **问题7: 动态改变DOM结构后，部分CSS样式丢失**
    *   **现象**: 将卡片元素移动到临时的 `captureWrapper` 进行居中截图后，卡片上的一些特定样式（如页脚文本对齐、标题颜色等）丢失或变回默认值。
    *   **原因**: 这些丢失的样式很可能依赖于卡片元素在其原始DOM结构中的特定父级上下文。例如，CSS规则可能是 `.card-style-cyberpunk .card-footer { text-align: right; }`。当卡片元素被移动到一个新的、没有 `.card-style-cyberpunk` 类名的 `captureWrapper` 的直接子级时，这些规则就不再匹配了。
    *   **解决**: 在创建临时的 `captureWrapper` 时，将其当前被截图卡片的主题样式类名 (例如 `card-style-cyberpunk`) 也应用到 `captureWrapper.className` 上。这样，即使卡片被移动，其内部元素仍然能匹配到依赖于该主题父类名的CSS规则。
    *   **建议**: 当为了截图等目的临时改变DOM结构时，必须仔细考虑CSS选择器的特异性 (specificity) 和上下文依赖。如果样式依赖于特定的父级类名或结构，应确保在新的临时结构中也维持这些必要的上下文条件。

## 项目最新进展

- **图片下载功能已完成**: 用户可以下载单张卡片或一次性下载所有生成的卡片。
- **代码清理完成**: 移除了所有注释掉的废弃代码，提高了代码可读性。
- **样式系统优化**: 使用Tailwind CSS与自定义CSS结合的方式，确保样式在开发和图片生成时的一致性。
- **字体处理优化**: 将Web字体本地化，解决了图片生成时字体显示问题。

## 未来可能的改进

-   支持更多图卡风格，并允许用户自定义部分样式（如颜色、字体）。
-   优化富文本内容的解析与显示（例如Markdown的更多元素支持）。
-   用户账户系统，保存用户的创作和偏好设置。
-   集成AI进行内容建议或摘要。
-   提供直接分享到社交媒体的功能。
-   增加图片尺寸和格式选择。

希望这些信息对你有用！ 